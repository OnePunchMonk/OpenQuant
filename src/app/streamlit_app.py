"""
AgentQuant: AI-Powered Autonomous Trading Research Platform
===========================================================

This module provides the main Streamlit web interface for the AgentQuant platform.
Users can generate AI-powered trading strategies, run backtests, and visualize results
through an intuitive dashboard.

Key Features:
- AI strategy generation using LLM agents
- Interactive backtesting with real market data
- Comprehensive performance visualization
- Risk analysis and portfolio optimization
- Export capabilities for further analysis

Dependencies:
- Streamlit: Web application framework
- pandas/numpy: Data manipulation and numerical computing
- matplotlib: Visualization and charting
- Custom modules: Agent planning, backtesting, data ingestion

Author: AgentQuant Development Team
License: MIT
"""

import os
import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from datetime import datetime, timedelta
import json
from typing import Dict, List, Any, Optional

# Internal module imports for core functionality
from src.agent.simple_planner import generate_strategy_proposals
from src.backtest.runner import run_backtest
from src.data.ingest import fetch_ohlcv_data, fetch_crypto_ohlcv, fetch_universe
from src.features.engine import compute_features
from src.features.regime import detect_regime
from src.utils.config import config
from src.visualization.plots import (
    plot_strategy_formula,
    create_strategy_dashboard,
    get_timestamp_folder
)
from src.strategies.lego_blocks import LEGO_BLOCKS, LEGO_BLOCK_MAP
from src.app.paper_trading import show_paper_trading


# Configure Streamlit page settings for optimal user experience
st.set_page_config(
    page_title="AlphaSwarm Web Dashboard",
    page_icon="ï¿½",
    layout="wide",
    initial_sidebar_state="expanded"
)


def load_available_assets() -> List[str]:
    """
    Load available assets from the data store directory.
    
    Scans the data_store directory for parquet files and extracts asset symbols.
    This allows the UI to dynamically populate available assets without hardcoding.
    
    Returns:
        List[str]: List of available asset symbols (e.g., ['SPY', 'QQQ', 'TLT'])
        
    Note:
        Returns empty list if data_store directory doesn't exist or contains no parquet files.
    """
    data_dir = os.path.join(os.getcwd(), "data_store")
    assets = []
    
    if os.path.exists(data_dir):
        for file in os.listdir(data_dir):
            if file.endswith(".parquet"):
                # Extract symbol by removing .parquet extension
                assets.append(file.split(".")[0])
    
    return assets


def load_available_strategies() -> List[str]:
    """
    Load the list of available strategy types supported by the platform.
    
    This function returns the strategy types that are implemented in the
    multi_strategy module and can be executed by the backtesting engine.
    
    Returns:
        List[str]: List of strategy names available for selection
        
    Strategy Types:
        - momentum: Moving average crossover and trend following
        - mean_reversion: Bollinger Bands and RSI-based signals  
        - volatility: Volatility targeting and VIX-based strategies
        - trend_following: Directional trend capture strategies
        - breakout: Range breakout and momentum strategies
        - regime_based: Market regime adaptive allocation
    """
    return [
        "momentum",
        "mean_reversion",
        "volatility",
        "trend_following",
        "breakout",
        "regime_based"
    ]


def optimize_strategy_parameters(strategy_info, data, num_trials=50):
    """
    Perform hyperparameter optimization for a strategy.
    
    Args:
        strategy_info: Dictionary with strategy information
        data: DataFrame with market data
        num_trials: Number of optimization trials
        
    Returns:
        Dictionary with optimized parameters
    """
    strategy_type = strategy_info["strategy_type"]
    assets = strategy_info["asset_tickers"]
    params = strategy_info["params"].copy()
    
    # Define parameter search spaces based on strategy type
    param_spaces = {}
    
    if strategy_type == "momentum":
        param_spaces = {
            "fast_window": {"min": 5, "max": 30},
            "slow_window": {"min": 30, "max": 100}
        }
    elif strategy_type == "mean_reversion":
        param_spaces = {
            "window": {"min": 10, "max": 60},
            "num_std": {"min": 1.0, "max": 3.0, "step": 0.2}
        }
    elif strategy_type == "volatility":
        param_spaces = {
            "window": {"min": 10, "max": 60},
            "vol_threshold": {"min": 0.01, "max": 0.05, "step": 0.005}
        }
    
    # Create trials with different parameter combinations
    best_sharpe = -np.inf
    best_params = params.copy()
    results = []
    
    for _ in range(num_trials):
        trial_params = params.copy()
        
        # Generate random parameters within the search space
        for param, space in param_spaces.items():
            if param in trial_params:
                if isinstance(trial_params[param], int):
                    trial_params[param] = np.random.randint(space["min"], space["max"])
                else:
                    step = space.get("step", 0.1)
                    trial_params[param] = np.random.choice(
                        np.arange(space["min"], space["max"] + step, step)
                    )
        
        # Run backtest with the trial parameters
        trial_info = strategy_info.copy()
        trial_info["params"] = trial_params
        
        try:
            backtest_result = run_backtest(
                data,
                trial_info["asset_tickers"],
                trial_info["strategy_type"],
                trial_info["params"],
                trial_info.get("allocation_weights")
            )
            
            sharpe = backtest_result.get("metrics", {}).get("Sharpe Ratio", -np.inf)
            
            # Store result
            result = {
                "params": trial_params,
                "sharpe": sharpe
            }
            results.append(result)
            
            # Update best parameters if better Sharpe ratio
            if sharpe > best_sharpe:
                best_sharpe = sharpe
                best_params = trial_params.copy()
        
        except Exception as e:
            st.error(f"Error during optimization trial: {str(e)}")
            continue
    
    # Return the optimized parameters
    return {
        "optimized_params": best_params,
        "trials": results,
        "best_sharpe": best_sharpe
    }


def main():
    st.sidebar.title("AlphaSwarm Dashboard")
    # Global mode toggle (Research / Paper Trading)
    view_mode = st.sidebar.radio("View Mode", ["Research", "Paper Trading"], index=0)
    asset_mode = st.sidebar.radio("Asset Mode", ["Stocks", "Crypto"], index=0, help="Toggle between yfinance equities and CCXT crypto markets.")

    if view_mode == "Paper Trading":
        show_paper_trading(asset_mode)
        return
    
    # Load available assets and strategies
    if asset_mode == 'Crypto':
        available_assets = config.get('crypto_universe', [])
    else:
        available_assets = load_available_assets()
    available_strategies = load_available_strategies()
    
    # Sidebar inputs
    st.sidebar.header("Backtest Settings")
    
    # Date range selection
    today = datetime.now()
    default_end_date = today - timedelta(days=1)
    default_start_date = default_end_date - timedelta(days=365*3)  # 3 years
    
    start_date = st.sidebar.date_input(
        "Start Date",
        value=default_start_date,
        max_value=default_end_date
    )
    
    end_date = st.sidebar.date_input(
        "End Date",
        value=default_end_date,
        max_value=today
    )
    
    # Asset selection
    selected_assets = st.sidebar.multiselect(
        "Select Assets",
        options=available_assets,
        default=available_assets[:4] if len(available_assets) >= 4 else available_assets
    )
    
    # Strategy generation options
    st.sidebar.header("Strategy Generation")
    lego_choice = st.sidebar.selectbox("Strategy Lego Block", ["AI Generate (Freeform)"] + [b['name'] for b in LEGO_BLOCKS], help="Pick a proven block to avoid hallucination or let AI generate freeform strategies.")
    
    # Lego Parameter Overrides
    lego_params = {}
    if lego_choice != "AI Generate (Freeform)":
        st.sidebar.subheader("Block Parameters")
        block = LEGO_BLOCK_MAP[lego_choice]
        for k, v in block["params"].items():
            if isinstance(v, int):
                lego_params[k] = st.sidebar.number_input(f"{k}", value=v, step=1)
            elif isinstance(v, float):
                lego_params[k] = st.sidebar.number_input(f"{k}", value=v, step=0.01, format="%.4f")
            else:
                lego_params[k] = v

    num_strategies = st.sidebar.slider(
        "Number of Strategies to Generate",
        min_value=1,
        max_value=10,
        value=5
    )    # AI Agent settings
    run_agent = st.sidebar.button("Generate Strategies")
    
    # Main content area
    st.title("AlphaSwarm: AI-Powered Quant Research")
    
    # Initialize session state for storing generated strategies
    if "strategies" not in st.session_state:
        st.session_state.strategies = []
    
    if "backtest_results" not in st.session_state:
        st.session_state.backtest_results = {}
    
    if "current_timestamp" not in st.session_state:
        st.session_state.current_timestamp = None
    
    # Run the AI agent if requested
    if run_agent:
        if not selected_assets:
            st.error("Please select at least one asset.")
            return
        
        # Show spinner during processing
        with st.spinner("Generating strategies with AI agent..."):
            try:
                # Fetch data (ensure SPY is included for reference calculations)
                # Unified data fetch
                if asset_mode == 'Crypto':
                    data = {sym: fetch_crypto_ohlcv(sym) for sym in selected_assets}
                else:
                    data = {}
                    assets_to_fetch = list(set(selected_assets + ['SPY']))
                    for asset in assets_to_fetch:
                        data[asset] = fetch_ohlcv_data(asset, start_date, end_date)
                
                # Compute features using all data and SPY as reference
                features_df = compute_features(data, ref_asset_ticker='SPY')
                
                # Detect market regime
                regime = detect_regime(features_df)
                
                # Run a baseline momentum strategy for comparison
                baseline_params = {"fast_window": 21, "slow_window": 63}
                baseline_result = run_backtest(
                    data,
                    [selected_assets[0]],
                    "momentum",
                    baseline_params
                )
                # Make robust to different return types (dict/Series/None)
                if isinstance(baseline_result, dict):
                    baseline_stats = pd.Series(baseline_result.get("metrics", {}))
                elif isinstance(baseline_result, pd.Series):
                    baseline_stats = baseline_result
                else:
                    baseline_stats = pd.Series({})
                
                # Normalize regime to a dict payload for downstream compatibility
                if isinstance(regime, str):
                    if 'HighVol' in regime or 'Crisis' in regime:
                        est_vol = 0.25
                    elif 'MidVol' in regime:
                        est_vol = 0.18
                    else:
                        est_vol = 0.12
                    regime_payload = {
                        'name': regime,
                        'current_regime': regime,
                        'current_volatility': est_vol
                    }
                elif isinstance(regime, dict):
                    regime_payload = regime
                else:
                    regime_payload = {'name': str(regime)}

                # Generate strategies with the AI agent
                if lego_choice != "AI Generate (Freeform)":
                    # Single lego block strategy
                    block = LEGO_BLOCK_MAP[lego_choice]
                    # Use user-overridden params if available
                    final_params = lego_params if lego_params else block["params"]
                    proposals = [{
                        "strategy_type": block["strategy_type"],
                        "asset_tickers": selected_assets,
                        "params": final_params,
                        "rationale": block["description"],
                        "allocation_weights": None
                    }]
                else:
                    proposals = generate_strategy_proposals(
                        regime_data=regime_payload,
                        features_df=features_df,
                        baseline_stats=baseline_stats,
                        strategy_types=available_strategies,
                        available_assets=selected_assets,
                        num_proposals=num_strategies
                    )
                
                # Store the generated strategies
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                st.session_state.current_timestamp = timestamp
                st.session_state.strategies = proposals
                
                # Create folder for saving results
                results_folder = get_timestamp_folder()
                
                # Run backtest for each strategy
                backtest_results = {}
                for i, strategy in enumerate(proposals):
                    try:
                        # Sanitize strategy params: rename threshold->threshold_pct, remove stray window keys
                        params = strategy.get("params", {}).copy()
                        if 'threshold' in params and 'threshold_pct' not in params:
                            params['threshold_pct'] = params.pop('threshold')
                        if strategy.get("strategy_type") in ['trend_following', 'regime_based'] and 'window' in params:
                            params.pop('window')
                        result = run_backtest(
                            data,
                            strategy["asset_tickers"],
                            strategy["strategy_type"],
                            params,
                            strategy.get("allocation_weights")
                        )
                        
                        # Store the result if backtest succeeded
                        strategy_key = f"Strategy {i+1}: {strategy['strategy_type']}"
                        if result is not None:
                            backtest_results[strategy_key] = {
                                "strategy_info": strategy,
                                "result": result,
                                "equity_curve": result.get("equity_curve"),
                                "weights": result.get("weights"),
                                "metrics": result.get("metrics")
                            }
                            
                            # Create dashboard plots
                            try:
                                # Get benchmark data safely
                                benchmark_data = None
                                try:
                                    if selected_assets[0] in data:
                                        benchmark_df = data[selected_assets[0]]
                                        if 'Close' in benchmark_df.columns:
                                            benchmark_data = benchmark_df["Close"]
                                        elif 'close' in benchmark_df.columns:
                                            benchmark_data = benchmark_df["close"]
                                        elif 'Adj Close' in benchmark_df.columns:
                                            benchmark_data = benchmark_df["Adj Close"]
                                except Exception:
                                    benchmark_data = None
                                
                                create_strategy_dashboard(
                                    equity_curve=result.get("equity_curve"),
                                    weights_df=result.get("weights"),
                                    strategy_info=strategy,
                                    benchmark=benchmark_data,
                                    save_path=results_folder
                                )
                            except Exception as plot_error:
                                st.warning(f"Failed to create plots for strategy {i+1}: {plot_error}")
                        else:
                            st.error(f"Backtest failed for strategy {i+1}: {strategy['strategy_type']}")
                        
                    except Exception as e:
                        st.error(f"Error running backtest for strategy {i+1}: {str(e)}")
                
                # Store the backtest results
                st.session_state.backtest_results = backtest_results
                
                st.success(f"Generated {len(proposals)} strategies and saved results to {results_folder}")
            
            except Exception as e:
                st.error(f"Error generating strategies: {str(e)}")
    
    # Display the generated strategies and results
    if st.session_state.strategies:
        st.header("Generated Trading Strategies")
        
        # Create tabs for the strategies
        strategy_tabs = st.tabs([f"Strategy {i+1}: {s['strategy_type']}" for i, s in enumerate(st.session_state.strategies)])
        
        for i, (tab, strategy) in enumerate(zip(strategy_tabs, st.session_state.strategies)):
            strategy_key = f"Strategy {i+1}: {strategy['strategy_type']}"
            
            with tab:
                # Display strategy details
                st.subheader(f"{strategy['strategy_type'].title()} Strategy")
                st.write(f"**Rationale**: {strategy['rationale']}")
                
                # Display parameters
                st.write("**Parameters:**")
                for param, value in strategy['params'].items():
                    st.write(f"- {param}: {value}")
                
                # Display asset allocation
                st.write("**Asset Allocation:**")
                if strategy.get('allocation_weights'):
                    allocation_df = pd.DataFrame([strategy['allocation_weights']])
                    st.dataframe(allocation_df)
                else:
                    st.write("Equal weighting across assets")
                
                # Display backtest results if available
                if strategy_key in st.session_state.backtest_results and st.session_state.backtest_results[strategy_key]["result"] is not None:
                    result_data = st.session_state.backtest_results[strategy_key]
                    
                    # Display metrics
                    st.subheader("Performance Metrics")
                    metrics_df = pd.DataFrame([result_data["metrics"]])
                    st.dataframe(metrics_df)
                    
                    # Create columns for the plots
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        # Plot equity curve
                        st.subheader("Portfolio Performance")
                        ec = result_data["equity_curve"]
                        if isinstance(ec, pd.DataFrame):
                            ec_series = ec.iloc[:,0]
                        else:
                            ec_series = ec
                        fig = go.Figure()
                        fig.add_trace(go.Scatter(x=ec_series.index, y=ec_series.values, name="Equity", mode="lines"))
                        fig.update_layout(title="Equity Curve", height=400, margin=dict(l=10, r=10, t=40, b=10))
                        st.plotly_chart(fig, use_container_width=True)
                    
                    with col2:
                        # Plot allocation weights
                        st.subheader("Asset Allocation")
                        weights_data = result_data["weights"]
                        if isinstance(weights_data, dict):
                            # Convert static weights dict to DataFrame for display
                            weights_df = pd.DataFrame([weights_data])
                            st.dataframe(weights_df)
                            # Also create a simple pie chart
                            alloc_df = pd.DataFrame(list(weights_data.items()), columns=["Asset","Weight"])
                            fig = go.Figure(data=[go.Pie(labels=alloc_df["Asset"], values=alloc_df["Weight"], hole=0.4)])
                            fig.update_layout(title="Asset Allocation", height=400)
                            st.plotly_chart(fig, use_container_width=True)
                        elif isinstance(weights_data, pd.DataFrame):
                            # Interactive stacked area of weights over time
                            fig = go.Figure()
                            for col in weights_data.columns:
                                fig.add_trace(go.Scatter(
                                    x=weights_data.index,
                                    y=weights_data[col],
                                    stackgroup='one',
                                    name=col
                                ))
                            fig.update_layout(title="Weights Over Time", height=400, margin=dict(l=10,r=10,t=40,b=10))
                            st.plotly_chart(fig, use_container_width=True)
                        else:
                            st.write("No allocation data available")
                    
                    # Plot strategy formula
                    st.subheader("Strategy Formula")
                    fig = plot_strategy_formula(strategy)
                    st.pyplot(fig)
                    plt.close(fig)
                    
                    # Add hyperparameter optimization option
                    st.subheader("Hyperparameter Optimization")
                    if st.button("Optimize Parameters", key=f"optimize_{i}"):
                        with st.spinner("Optimizing parameters..."):
                            try:
                                # Get the data for optimization (ensure SPY is included for reference)
                                data = {}
                                assets_to_fetch = list(set(strategy["asset_tickers"] + ['SPY']))
                                for asset in assets_to_fetch:
                                    data[asset] = fetch_ohlcv_data(asset, start_date, end_date)
                                
                                # Run optimization
                                opt_result = optimize_strategy_parameters(
                                    strategy,
                                    data,
                                    num_trials=30
                                )
                                
                                # Display optimization results
                                st.success("Optimization complete!")
                                
                                # Show optimized parameters
                                st.write("**Optimized Parameters:**")
                                for param, value in opt_result["optimized_params"].items():
                                    st.write(f"- {param}: {value}")
                                
                                st.write(f"**Best Sharpe Ratio:** {opt_result['best_sharpe']:.4f}")
                                
                                # Option to apply optimized parameters
                                if st.button("Apply Optimized Parameters", key=f"apply_opt_{i}"):
                                    # Update strategy with optimized parameters
                                    strategy["params"] = opt_result["optimized_params"]
                                    
                                    # Re-run backtest with optimized parameters
                                    result = run_backtest(
                                        data,
                                        strategy["asset_tickers"],
                                        strategy["strategy_type"],
                                        strategy["params"],
                                        strategy.get("allocation_weights")
                                    )
                                    
                                    # Update stored results
                                    st.session_state.backtest_results[strategy_key]["result"] = result
                                    st.session_state.backtest_results[strategy_key]["equity_curve"] = result.get("equity_curve")
                                    st.session_state.backtest_results[strategy_key]["weights"] = result.get("weights")
                                    st.session_state.backtest_results[strategy_key]["metrics"] = result.get("metrics")
                                    
                                    # Rerun the app to show updated results
                                    st.experimental_rerun()
                            
                            except Exception as e:
                                st.error(f"Error during optimization: {str(e)}")
                else:
                    st.warning("No backtest results available for this strategy.")
    
    else:
        st.info("Click 'Generate Strategies with AI Agent' to get started.")


if __name__ == "__main__":
    main()
